
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Multiple Regression</title>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
		<link rel="stylesheet" type="text/css" href="styles/tln.min.css"/>
		<link rel="stylesheet" type="text/css" href="styles/statstyle.css">
		<style>
		.corMatrix {border-spacing: 0px;}
		.corMatrix td {border:1px #DDD solid; padding:3;}
		.corMatrix th {padding:3}
		
		</style>
		
		<script type="text/javascript" src="js/jstat.js"></script>
		<script type="text/javascript" src="js/commonFunctions.js"></script>
		<script type="text/javascript" src="js/chartFunctions.js"></script>
		<script type="text/javascript" src="js/jsregression.min.js"></script>
		<script type="text/javascript" src="js/numeric-1.2.6.min.js"></script>
		<script type="text/javascript" src="js/shapiro-wilk.js"></script>
		<script type="text/javascript" src="js/tln.min.js"></script>
		<script type="text/javascript" src="js/math.min.js"></script>
		<script type="text/javascript" src="js/mlr.js"></script>
		<script type="text/javascript" src="js/glm.js"></script>
		<script language="javascript">
			var debug=false
			var debugPred=false
			var timing=true
			var nCovars = 2
			var nVars = 3
			var modelN=0
			var responseVarNum = 1
			var responseVarLevel = 0
			var X = []
			var XXTinv = []
			var Y = []
			var varMatrix = new Array
			var dataMatrix = new Array
			var modelY = new Array
			var predictY = new Array
			var yHat = new Array
			var MSE = 0
			var varNames = []
			var modelVarNames = []
			var modelVarIsFactor = []
			var modelVarNamesVarNum = []
			var modelVarNamesTransform = []
			var modelVarNamesFactorValue = []
			var scatterLabels=[]
			var isFactor = []
			var isInteger=[]
			var levels = []
			var coeff = new Array
			var Resid = new Array
			var residuals = new Array
			var nSamples=3
			var nObs = 1
			var modelN=0
			var baselineLevel = []
			var varInModel=[]
			var varLevelInModel=[]
			var varTransformsInModel=[]

			var varCol = []
			var lvlCol = []
			var validRegression = false;
			var nQuantPredictors = 0
			
			
			//If debugging will output the data matrix to be viewed
			function peekAtData(dataObject){
				if(debug && exists('dataMatrix')){
				stringOutput=""
				for(var i=0; i<dataObject.length; i++)
					stringOutput += JSON.stringify(dataObject[i])+"\n<br>"
				document.getElementById('dataMatrix').innerHTML=stringOutput
				}
			}
			
			//returns TRUE if the response is an integer or categorical
			function isLogistic(){
				return (isFactor[responseVarNum] || isInteger[responseVarNum]);
			}
			
			//returns an array with only the unique values
			function onlyUnique(value, index, self) { 
				return self.indexOf(value) === index;
			}

			//Creates a matrix of all variable data as entered (varMatrix)
			function cleanData(set=1){
				var startTime=new Date().getTime()
				var data = document.getElementById("data"+set).value.trim().split(/[\n]+/)
				if(debug)console.log(data)
				var n=data.length
				
				var delimRegEx = "["
				if(document.getElementById('delimSpace').checked) delimRegEx +="\\s"
				if(document.getElementById('delimComma').checked) delimRegEx +=","
				if(document.getElementById('delimSemicolon').checked) delimRegEx +=";"
				if(document.getElementById('delimTab').checked) delimRegEx +="\\t"
				delimRegEx += "]+"

//				console.log(delimRegEx)
				delimRegEx = new RegExp(delimRegEx)
//				console.log(delimRegEx)

				document.getElementById('nCovars').value = Math.max(data[0].trim().split(delimRegEx).length-1,1)
				nCovars = Math.max(data[0].trim().split(delimRegEx).length-1,1)

				if(n==1 && data[0]=="") n=0;
				var myArray = [];
				
				//Make Var Matrix
				varMatrix=new Array(nCovars+1)
				for(var i=0; i<nCovars+1; i++){
					varMatrix[i]=new Array(n)
				}
//				console.log("var Array is "+(nCovars+1)+" x "+n)


				for (var i = 0; i<n; i++){				
//					console.log("data: "+data[i])
//					console.log("data: "+data[i].split(/[\s,;\t]+/))

					var vars = data[i].trim().split(delimRegEx)
					myArray.push(vars)

					if(debug) console.log("There are "+vars.length+" vars: "+vars)
					for(var j=0; j<vars.length; j++) {
						varMatrix[j][i]=vars[j]
					}
//					console.log(varMatrix[0][0])
				}
				
//				data = myArray
				//peekAtData(data)
//				n=data.length
				var dataInput = ""
				
				for( var i=0; i<n; i++){
					for(var k=0; k<varMatrix.length; k++){
						if (k>0) dataInput += "\t"
						dataInput += varMatrix[k][i] 
					}
					if(i<n-1) dataInput += "\n"
				}
				
				document.getElementById("data"+set).value=dataInput
				for(var k=1; k<=varMatrix.length; k++){
					isFactor[k]=false;
					isInteger[k]=true;
					
					for(var i=0; i<n; i++){
						if (!isNumeric(varMatrix[k-1][i]) || isFloat(varMatrix[k-1][i])){
							isInteger[k]=true
							break;
						}
					}
					if(n>0){
						if(!isNumeric(varMatrix[k-1][0])) isFactor[k]=true;
						if(!isNumeric(varMatrix[k-1][0]) || isInteger[k]){
							levels[k-1] = varMatrix[k-1].filter( onlyUnique )
							levels[k-1].sort();
							if(baselineLevel[k-1]==null) baselineLevel[k-1]=0
							//alert(data.filter( onlyUnique ));
						}
					}
				}
				if(timing) console.log("Data Cleaned: "+(new Date().getTime()-startTime))

				createDataMatrix()
			}
			
			function isCategorical(varNum){
				//console.log(isFactor)	
			}
			
			//and creates a numerical data matrix, with one column for every dummy variable, even the baselines (dataMatrix)
			function createDataMatrix(){
				var startTime = new Date().getTime()
//				alert('creating data matrix')
				dataMatrix=[]
//				varMatrix=[]
				var activeCol = 0
				var regType=document.getElementById('regressionType').value
				for(var i=1; i<= nCovars+1; i++){
					varCol[i-1] = activeCol
					var data=getColumn(i, false)
					var n=data.length
//					console.log("ResponseVarNum="+responseVarNum+", regType="+regType)
					if(isFactor[i]==true || exists("v"+i+"d") && document.getElementById("v"+i+"d").checked || (responseVarNum==i && regType==2)){
//						varMatrix.push(data)
						for(var lvl=0; lvl<levels[i-1].length; lvl++){
							var dummyColumn= []
							for(var k=0; k<n; k++){
								dummyColumn[k] = (data[k]===levels[i-1][lvl]?1:0)
							}
							dataMatrix.push(dummyColumn.map(i => +i))
							activeCol++
						}
					}else{
						dataMatrix.push(data.map(i => +i))
						activeCol++
//						varMatrix.push(data.map(i => +i))
					}
				}
				//isCategorical(1)
				//peekAtData(dataMatrix)
				if(timing) console.log("DataMatrix created: "+(new Date().getTime()-startTime))
			}
			
			//returns a vector for a variable and level (if it is a factor)
			function getData(varIndex, level=0){
				if(varIndex<0){return false;}
				if(debug) console.log("var index "+varIndex+" level "+level+" in col "+(varCol[varIndex]+level));
				if(debug) console.log(dataMatrix[varCol[varIndex]+level])
				if(dataMatrix.length>0 && dataMatrix.length> +(varCol[varIndex]+level)){
					return dataMatrix[+varCol[varIndex]+level].slice(0)
				} else {
					return false;
				}
			}
		
			//returns a column of the varMatrix, not the data matrix
			function getColumn(set, forceNumeric=true){
				if(varMatrix.length>=set){
					return varMatrix[set-1].slice()
				} else {
					return false
				}
			}
			
			//subroutine - only called from sampleStates()
			function computeStats(set, data){
				var n=data.length
				document.getElementById("stat_n"+set).innerHTML =  n  
				if(!isFactor[set]){
					data.sort(function(a, b){return a-b})
					for(var i=0; i<n; i++) { data[i] = +data[i]; }
					var fiveNumSummary = fiveNumSum(data)
					document.getElementById("stat_xbar"+set).innerHTML = +(jStat.mean(data)).toFixed(precision)  
					document.getElementById("stat_median"+set).innerHTML = +(fiveNumSummary[2]).toFixed(precision) 
					dataMode = jStat.mode(data)
					if(dataMode.length == n) {document.getElementById("stat_mode"+set).innerHTML = "none"}
					else{ document.getElementById("stat_mode"+set).innerHTML = dataMode}
					document.getElementById("stat_midrange"+set).innerHTML = +((jStat.max(data) + jStat.min(data))/2).toFixed(precision) 
					document.getElementById("stat_min"+set).innerHTML = +(fiveNumSummary[0]).toFixed(precision) 
					document.getElementById("stat_Q1"+set).innerHTML = +fiveNumSummary[1].toFixed(precision) 
					document.getElementById("stat_Q3"+set).innerHTML = +fiveNumSummary[3].toFixed(precision) 
					document.getElementById("stat_max"+set).innerHTML = +(fiveNumSummary[4]).toFixed(precision)  
					document.getElementById("stat_range"+set).innerHTML = +jStat.range(data).toFixed(precision)  
					document.getElementById("stat_IQR"+set).innerHTML = +(fiveNumSummary[3]-fiveNumSummary[1]).toFixed(precision) 
					document.getElementById("stat_var"+set).innerHTML = +(jStat.variance(data,true)).toFixed(precision)  
					document.getElementById("stat_s"+set).innerHTML = +(jStat.stdev(data,true)).toFixed(precision) 
					if(exists("stat_sx"+set)) document.getElementById("stat_sx"+set).innerHTML = +(jStat.stdev(data,true)/Math.sqrt(n)).toFixed(precision) 
					if(exists("stat_sigma"+set)) document.getElementById("stat_sigma"+set).innerHTML = +(jStat.stdev(data)).toFixed(precision) 	
					document.getElementById("stat_skew"+set).innerHTML = +(jStat.skewness(data)).toFixed(precision)  
					document.getElementById("stat_kurtosis"+set).innerHTML = +(jStat.kurtosis(data)+3).toFixed(precision) 		
				} else {
//					alert(set)
//					alert(levels[set-1])
//					alert(levels[set-1])
					var mode = levels[set-1][0]
					data = getColumn(set,false)
					var freqs = []
					var maxFreq = 0
					var lvls= levels[set-1]
					for(var k=0; k<lvls.length; k++){
						freqs[k]=0
						for(var j=0; j<data.length; j++){
							if(data[j]==lvls[k]) freqs[k]++
						}
						if(freqs[k]>maxFreq) maxFreq = freqs[k]
					}
					var modes=""
					var first = true
					for(var k=0; k<lvls.length; k++){
						if(freqs[k]==maxFreq){
							modes += (first==true?"":", ")
							modes += lvls[k]
							first=false
						}
					}
					document.getElementById("stat_mode"+set).innerHTML = modes
				}
			}
		
			//Copy the names of all variable columns into the summary stats locations
			//And compute all sample stats
			function sampleStats(nSets) {
				var startTime = new Date().getTime();
				if(varMatrix[0].length==0) return false;
				for(var set=1; set<=nSets; set++){
					var data = varMatrix[set-1].slice()
					nObs=data.length
					data.sort(function(a, b){return a-b})
					computeStats(set,data)
					var varName = document.getElementById("name"+set).value;
					document.getElementById("statsName"+set).innerHTML = varName;
				}
				
				
				//Count how many variables are quantitative
				var nQuantSets = 0
				//alert(isFactor)
				for(var i=1; i<=nSets; i++){
					if(!isFactor[i]) nQuantSets++
				}
				//alert(nQuantSets)
				
				
				//Create an empty correlation matrix with 1 fewer rows than the
				//number of quantitative variables
				var corMatrix = []
				for(var i=0; i<nQuantSets; i++){
					corMatrix[i]=Array(nQuantSets)
					for(var j=0; j<=nQuantSets-1; j++){
						corMatrix[i][j]=""
					}
				}
				var j=1
				var cmColVars=[], cmRowVars=[]
				for(var i=1; i<=nSets; i++){
					if(!isFactor[i]){
						if(j<nQuantSets) {
							corMatrix[j][0]=document.getElementById("name"+i).value
							cmRowVars.push(i)
						}
						if(j>1){
							corMatrix[0][j-1]=document.getElementById("name"+i).value
							cmColVars.push(i)
						}
						j++
					}
				}

				for(var cmRow=1; cmRow<corMatrix.length; cmRow++){
					var dataA=getData(cmRowVars[cmRow-1]-1)
					for(var cmCol=1; cmCol<corMatrix[cmRow].length; cmCol++){
						var dataB=getData(cmColVars[cmCol-1]-1)
						corMatrix[cmRow][cmCol]=fixed(jStat.corrcoeff(dataA,dataB))
					}
				}
				
				if(debug)console.log(JSON.stringify(corMatrix))
				var outputCorMatrix = "<strong>Correlations</strong><br><table class='corMatrix'>"
				for(var i=0; i<nQuantSets; i++){
					outputCorMatrix += "<tr>"
//					for(j=0; j<i; j++)
//					outputCorMatrix+="<td></td>"
					for(var j=0; j<nQuantSets; j++){
						if(i==0){
							if(j>0) {outputCorMatrix+="<th>"+corMatrix[j][i]+"</th>"
							}else{
							outputCorMatrix+="<th></th>"
							}
							
						}else{
							if(j==0){
								outputCorMatrix+="<th>"+corMatrix[j][i]+"</th>"
							} else{
								outputCorMatrix+="<td>"+corMatrix[j][i]+"</td>"
							}
						}
					}
					outputCorMatrix += "</tr>"
				}
				outputCorMatrix += "</table>"
				document.getElementById("corMatrix").innerHTML=outputCorMatrix
				if(timing) console.log("Sample Stats Calculated: "+(new Date().getTime()-startTime))
			}
			
			//preps the data for creating a residual plot, and creates the residual plot
			function prepDataForResidualPlot(){
				var sel=document.getElementById("ResidVar")
				var residXVar = sel.value
				var residLabel = sel.options[sel.selectedIndex].text
				var catX = residXVar.indexOf("c")==0
//				console.log(residXVar + " " + catX)
				if(catX) residXVar = parseInt(residXVar.replace("c",""))
				
				var absResid = document.getElementById('absResid').checked
				if(residXVar=="predicted"){
				//	alert(yHat)
					var responseVar =document.getElementById("ChooseResponse").value;
					residualplot(yHat, residLabel, absResid)
				} else if(residXVar=='order'){
					var Xdata=[]
					for(var i=1; i<= yHat.length; i++) Xdata.push(i)
					residualplot(Xdata,residLabel, absResid)
				} else if(catX){
					var	xVals=levels[residXVar-1]
					var	Xdata=getColumn(residXVar)
					for(var i=0; i<Xdata.length; i++){
						for(var k=0; k<xVals.length; k++){
							if(Xdata[i]==xVals[k]) Xdata[i]=k
						}
					}
					console.log("xVals are "+xVals)
					residualplot(Xdata,residLabel,absResid,xVals)
				}else{
					var XVar = parseInt(document.getElementById("ResidVar").value)
					var Xfull = numeric.transpose(window.X)
					var Xdata = window.modelY
					if(XVar > 0) Xdata = Xfull[XVar]
					residualplot(Xdata,residLabel, absResid)
				}
			}
				
			function minv(A){
				return math.inv(A)
			}
						
			function determineVarsInModel(){
				var startTime = new Date().getTime()
				//baselineLevel = []
				varInModel=[]
				varLevelInModel=[]
				varTransformInModel=[]
				for(var varNum=1; varNum<=nCovars+1; varNum++){
					varLevelInModel[varNum]=[]
					varTransformInModel[varNum]=[]
					varInModel[varNum]=false
					for(var k=0; k<=4; k++){
						varTransformInModel[varNum][k]=false
						if(exists('v'+varNum+"t"+k) && document.getElementById('v'+varNum+"t"+k).checked){
							varInModel[varNum]=true
							varTransformInModel[varNum][k]=true
						}
					}
					if(exists("v"+varNum+"d") && document.getElementById("v"+varNum+"d").checked==true){
						varInModel[varNum]=true
						for(var j=0; j<levels[varNum-1].length; j++){
							if(exists("v"+varNum+"_"+levels[varNum-1][j]) && document.getElementById("v"+varNum+"_"+levels[varNum-1][j]).checked==true){
								varLevelInModel[varNum][j]=false
								if(baselineLevel[varNum-1]!=j){
									varLevelInModel[varNum][j]=true
								}
							}
						}						
					}
				}
				
//				console.log(varInModel)
//				console.log(varLevelInModel)
//				console.log(varTransformInModel)
				if(timing) console.log("Determine Vars in Model: "+(new Date().getTime()-startTime))

			}
				
			function transformName(varNum, transform){
				var varName = document.getElementById("name"+varNum).value
//				var varName = varNames[varNum]
				if(transform==1) varName = varName+"²"
				if(transform==2) varName = varName+"³"
				if(transform==3) varName = "ln("+varName+")"
				if(transform==4) varName = "\u221A<span style='text-decoration:overline'>"+varName+"</span>"			
				return varName
			}
					
			function linReg(){
				var startTime = new Date().getTime()
//				alert("starting lin reg")
				if(debug)console.log("doing linear regression now")
				var alpha = 1-parseFloat(document.getElementById("cLevel").value)
				var equation =""
				Y = []
				var regType=document.getElementById('regressionType').value
				determineVarsInModel()
				if(regType==1){
					Y = getColumn(responseVarNum)
				} else {
					updateResponseVarLevel()
					if(debug)console.log(responseVarNum+" "+responseVarLevel)
					Y = getData(responseVarNum-1, responseVarLevel)
				}
				
				if(Y==false){
					if(debug)console.log("Y false, ending regression fail")
					validRegression=false
					return false;
				
				}
				var n = Y.length

				for(var i=0; i<n; i++) { 
					if(document.getElementById("responseTransform").value==1) {
						Y[i] = +Y[i]; 
					} else if(document.getElementById("responseTransform").value==2) {
						Y[i] = +Math.log(Y[i]);		
					}
				}
//				peekAtData(dataMatrix)
//				console.log(Y)
				modelY = Y
				varNames=[]
				var yName = document.getElementById("name"+responseVarNum).value
				if(document.getElementById("responseTransform").value==2) yName = "ln("+yName+")"
				varNames.push(yName)
				var Ydevs=new Array(n)
				
				//Only for linear regression----------\\
//				console.log(jStat.mean(Y))
				for(var i=0; i<n; i++) { 
					Ydevs[i]=+Y[i]-jStat.mean(Y)
				}
				//------------------------------------//
//				alert("checkpoint 2")

				
				modelN=0 //counts the number of predictors (slope coefficients)
				modelVarNames = []
				modelVarIsFactor = []
				modelVarNamesTransform=[]
				modelVarNamesVarNum=[]
				modelVarNamesFactorValue=[]
				coeff=[]
				modelVarNames[0]="Intercept"
				modelVarIsFactor[0] = false
				modelVarNamesVarNum[0]=0
				modelVarNamesTransform[0]=0
				nQuantPredictors = 0
				
				X=[]
				Ones = new Array(n)
				for(var i =0; i< n; i++){Ones[i]=+1}
				if(regType==1)	X.push(Ones)
				for(var varNum=1; varNum<=nCovars+1; varNum++){
					if(varInModel[varNum]){
						data=getColumn(varNum)
						var quantPredictorCounted=false
						for(var k=0; k<5; k++){
							if(varTransformInModel[varNum][k]){
								if(!quantPredictorCounted){
									nQuantPredictors++
									quantPredictorCounted=true
								}
								modelN++
								var tData = new Array(n)
								for(var j=0; j<n; j++) tData[j] = +transform(+data[j],k); 
								X.push(tData)
								modelVarNames.push(transformName(varNum,k))
								modelVarIsFactor.push(false);
								modelVarNamesVarNum.push(varNum)
								modelVarNamesTransform.push(k)
								modelVarNamesFactorValue.push(0)
							}
						}
						for(var lvl=0; lvl<varLevelInModel[varNum].length; lvl++){
							if(varLevelInModel[varNum][lvl]){
								var dummyX = getData(varNum-1, lvl)
								X.push(dummyX)
								modelVarNames.push(document.getElementById("name"+varNum).value+"<sub>"+levels[varNum-1][lvl]+"</sub>")
								modelVarIsFactor.push(true)
								modelVarNamesVarNum.push(varNum)
								modelVarNamesTransform.push(0)
								modelVarNamesFactorValue.push(levels[varNum-1][lvl])
								modelN++
							}
						}
					}
				}
				
//				alert("checkpoint 3")
				
				for(var varNumA=2; varNumA<=nCovars+1; varNumA++){
					var aData = getColumn(varNumA)
					for(var varNumB=1; varNumB<varNumA; varNumB++){
						var bData = getColumn(varNumB)
						if(interactionInModel(varNumB,varNumA)){
							var quantA=!isFactor[varNumA]
							var quantB=!isFactor[varNumB]
							if(quantA && quantB){
								modelN++
								var tData = new Array(n)
								for(var i=0; i<n; i++) tData[i]=aData[i]*bData[i]
								X.push(tData)
								modelVarNames.push(getVarName(varNumB)+"&#215;"+getVarName(varNumA))
								modelVarNamesVarNum.push(varNumB + "."+varNumA)
								modelVarNamesTransform.push(0)
								modelVarNamesFactorValue.push(0)
							}else{
								if(debug)console.log("Interaction of "+varNumA+" and "+varNumB)
								var nLevelsA = (quantA?1:levels[varNumA-1].length)
								var nLevelsB = (quantB?1:levels[varNumB-1].length)
								if(debug)console.log("var"+varNumA+" has "+nLevelsA+" levels, var"+varNumB+" has "+nLevelsB+" levels")
								for(var a=0; a<nLevelsA; a++){
									if(quantA || varLevelInModel[varNumA][a]){
										aData = getData(varNumA-1,a)
										for(var b=0; b<nLevelsB; b++){
											if(quantB || varLevelInModel[varNumB][b]){
												bData = getData(varNumB-1,b)
												modelN++
												var tData = new Array(n)
												for(var i=0; i<n; i++) tData[i]=aData[i]*bData[i]
												X.push(tData)
												var nameA = getVarName(varNumA) + (quantA?"":"<sub>"+levels[varNumA-1][a]+"</sub>")
												var nameB = getVarName(varNumB) + (quantB?"":"<sub>"+levels[varNumB-1][b]+"</sub>")
												modelVarNames.push(nameA + "&#215;" + nameB)
												modelVarNamesVarNum.push(varNumB + "."+varNumA)
												modelVarNamesTransform.push(0)
												modelVarNamesFactorValue.push((quantB?"_":levels[varNumB-1][b])+"."+(quantA?"_":levels[varNumA-1][a]))
											}
										}	
									}
								}
							}
						}
					}
				}

//				alert("checkpoint 4")

				if(debug)console.log(modelVarNames)
				if(debug)console.log(modelVarNamesVarNum)
				if(debug)console.log(modelVarNamesFactorValue)
				
				if(modelVarNames.length==1){
					validRegression=false
					document.getElementById("linRegOutput").innerHTML="<strong>Error in Regression Options</strong><br>Select at least one predictor variable."
					return;
				}
				
			//	alert("checkpoint 5")

				
				X = numeric.transpose(X)
				var outputString ="<strong>Regression Statistics</strong><br>\n"
				outputString +="Equation: <span id='equation'></span><br>\n"
				var totalDF = n-1
				var betweenDF = modelN
				var withinDF = totalDF-betweenDF
				var logisticReg = (document.getElementById('regressionType').value==2)
				document.getElementById('residContainer').style.display=logisticReg?"none":"block";

				if(regType==1){
					equation +="<span class='hat'>"+yName+"</span> = "	

					var startTimer =  new Date().getTime()
					var Xt = numeric.transpose(X)
					var XtX = numeric.dot(Xt,X)
					XXTinv = pinv(XtX)
					if(timing) console.log("pinv: " + (new Date().getTime() - startTimer))
					
//					var startTimer =  new Date().getTime()
//					var XXTinvM = minv(math.multiply(math.transpose(math.matrix(X)),math.matrix(X)))
//					if(timing) console.log("minv: "+(new Date().getTime() - startTimer))
					
//					console.log(XXTinv)
					if(XXTinv==false){
						document.getElementById("linRegOutput").innerHTML="Linear Dependence Among Predictors - check inputs"
						validRegression=false;
						return false;
					}
					validRegression=true;


				//	var startTimer =  new Date().getTime()
				//	var A = math.qr(X)
				//	if(timing) console.log("qr: " + (new Date().getTime() - startTimer))

					var startTimer =  new Date().getTime()
					
//					H = math.multiply(math.multiply(math.matrix(X), math.matrix(XXTinv)),math.matrix(Xt))
//					H = numeric.dot(numeric.dot(X, XXTinv),Xt)
					var XXtinvXt = numeric.dot( XXTinv,Xt)
					var H = numeric.dot(X,XXtinvXt)
				
					
					if(timing) console.log("H: " + (new Date().getTime() - startTimer))
					var startTimer =  new Date().getTime()

					yHat = numeric.dot(H,Y)
					if(timing) console.log("yHat: " + (new Date().getTime() - startTimer))
					var startTimer =  new Date().getTime()

					Resid = numeric.sub(Y,yHat)
					residuals = Resid.slice()

					if(timing) console.log("residuals: " + (new Date().getTime() - startTimer))

					var startTimer =  new Date().getTime()
					var b = numeric.dot(XXtinvXt,Y)
					
					var totalSS = jStat.sumsqrd(Ydevs)
					var withinSS = jStat.sumsqrd(Resid)
					var betweenSS = totalSS- withinSS
					var betweenMS = betweenSS/betweenDF
					var withinMS = withinSS/withinDF //MSerror
					MSE = withinMS
					var F = betweenMS/withinMS
					var sigF = 1-jStat.centralF.cdf(F,betweenDF,withinDF)
					var Rsq = betweenSS/totalSS
					var R = Math.sqrt(Rsq)
					var AdjRsq = 1-(1-Rsq)*(n-1)/(n-modelN-1)
					var stdError = Math.sqrt(withinMS)
					
					var bStdError = new Array(b.length)
					var SSCPinv = pinv(XtX)
					for(var i=0; i<b.length; i++){
						bStdError[i]= Math.sqrt(withinMS*SSCPinv[i][i])
					}
					
					
					outputString +="Multiple R : "+R.toFixed(precision) + "<br>\n"
					outputString +="R Squared : "+Rsq.toFixed(precision) + "<br>\n"
					if( n > 2 ){ 
						outputString +="Adjusted R Squared : "+ AdjRsq.toFixed(precision) + "<br>\n"
						outputString +="Standard Error : " + stdError.toFixed(precision) + "<br>\n"
					}
					outputString += "Observations : " + n + "<br>\n"
					outputString += "<br>\n"
					
					outputString += "<strong>ANOVA Output</strong><br>\n"
					outputString +="<div class='overflowX'>"
					outputString += "<table class='anova'>\n"
					outputString += "<tr><th></th><th>df</th><th>SS</th><th>MS</th><th>F</th><th>Sig. F</th></tr>"
					outputString += "<tr><td>Regression</td><td>"+betweenDF+"</td><td>"+betweenSS.toFixed(precision)+"</td><td>"+betweenMS.toFixed(precision)+"</td><td>"+F.toFixed(precision)+"</td><td>"+sigF.toFixed(precision)+"</td></tr>"
					outputString += "<tr><td>Residual</td><td>"+withinDF+"</td><td>"+withinSS.toFixed(precision)+"</td><td>"+withinMS.toFixed(precision)+"</td><td></td><td></td></tr>"
					outputString += "<tr><td>Total</td><td>"+totalDF+"</td><td>"+totalSS.toFixed(precision)+"</td><td></td><td></td><td></td></tr>"
					outputString +="</table>"
					outputString +="</div>"
					outputString +="<br>\n"	
										
					outputString += "<strong>Regression Output</strong><br>\n"
					outputString +="<div class='overflowX'>"
					outputString += "<table class='anova'>\n"
					outputString += "<tr><th></th><th>Coefficient</th><th>Std. Error</th><th>t Stat</th><th><i>p</i>-value</th><th>lower "+fixed((1-alpha)*100)+"%</th><th>upper "+fixed((1-alpha)*100)+"%</th></tr>"
					
					for(var i=0; i<modelVarNames.length; i++){
						coeff[i]=b[i]
						if (i>0){ 
							equation+=" + "+b[i].toFixed(precision) + "<i>"+modelVarNames[i]+"</i>"
						} else {
							equation+=b[0].toFixed(precision)
						}
						var t = b[i]/bStdError[i]
						var pVal = 2*jStat.studentt.cdf(-Math.abs(t),n-modelN-1)
						var CI = [b[i]-jStat.studentt.inv(1-alpha/2,n-modelN-1)*bStdError[i] , b[i]+jStat.studentt.inv(1-alpha/2,n-modelN-1)*bStdError[i]]
						
						outputString += "<tr><td>"+modelVarNames[i]+"</td><td id='b"+i+"'>"+b[i].toFixed(precision)+"</td><td>"+bStdError[i].toFixed(precision)+"</td><td>"+t.toFixed(precision)+"</td><td>"+pVal.toFixed(precision)+"</td><td>"+CI[0].toFixed(precision)+"</td><td>"+CI[1].toFixed(precision)+"</td></tr>"
					}
					outputString +="</table>"
					outputString +="</div>"
					
					if(timing) console.log("write output: " + (new Date().getTime() - startTimer))

					
				} else if (regType==2){
					responseVarNum=+document.getElementById('ChooseResponse').value
					equation +="<span class='hat'>log-odds</span>("+yName+"="+levels[responseVarNum-1][responseVarLevel]+") = "	
					Xtrain2 = new Array(X.length)
					var nVars = X[0].length
					for(var i=0; i<Xtrain2.length; i++){
						Xtrain2[i]=new Array(nVars+1)
						for(var j=0; j<nVars;j++) Xtrain2[i][j]=X[i][j]
						Xtrain2[i][nVars]=1
					}					
					
					var glm_model = GLM(GLM.families.Binomial());
					
//					peekAtData(Xtrain2)
					glm_model.fit(Y,X)
					if(!glm_model.weights) {
						validRegression=false;
						outputString="Error in Matrix Decomposition; Fit did not converge."
					} else {
						validRegression=true;
//						console.log("trained")
						coeff=glm_model.weights
						predictY=glm_model.predict(X)
//						console.log("predictY="+predictY)
						var dev = 0.0; 
						for (var i = 0; i < predictY.length; i++) {
							var one = Y[i] == 1 ? 1 : 0; 
							dev += one * Math.log(predictY[i] + 1e-200) + (1 - one) * Math.log(1 - predictY[i] + 1e-200);
						}
						dev *= -2.0
						
						ones = new Array(predictY.length)
						for(var i=0; i<ones.length; i++)
							ones[i]=new Array(0)
						null_model=GLM(GLM.families.Binomial());
						null_model.fit(Y,ones)
						nullpredictY=null_model.predict(ones)

						var nulldev = 0.0; 
						for (var i = 0; i < predictY.length; i++) {
							var one = Y[i] == 1 ? 1 : 0; 
							nulldev += one * Math.log(nullpredictY[i] + 1e-200) + (1 - one) * Math.log(1 - nullpredictY[i] + 1e-200);
						}
						nulldev *= -2.0
						Hessian = new Array(coeff.length)
						for(var row=0; row<Hessian.length; row++){
							Hessian[row]=new Array(coeff.length)
							for(var col=0; col<Hessian.length; col++){
								Hessian[row][col]=0
								for(var j=0; j<predictY.length; j++){
									var h = predictY[j]
									Hessian[row][col] += Xtrain2[j][row] * Xtrain2[j][col]*h*(1-h)
								}
							}
						}
						HessianInv = pinv(Hessian)
						var stdError = new Array(coeff.length)
						var pVals = new Array(coeff.length)
						for(var i=0; i<stdError.length; i++){
							stdError[i]=Math.sqrt(HessianInv[i][i])
							pVals[i]=2*jStat.normal.cdf(-Math.abs(coeff[i]),0,stdError[i])
						}

						var threshold = +document.getElementById('predictYesLevel').value;
						var truePos=0, falseNeg=0, falsePos=0, trueNeg=0
						for(var i=0; i<predictY.length; i++){
							if(predictY[i]>=threshold && Y[i]==1) truePos++
							if(predictY[i]>=threshold && Y[i]==0) falsePos++
							if(predictY[i]<threshold && Y[i]==1) falseNeg++
							if(predictY[i]<threshold && Y[i]==0) trueNeg++
						}
						
						var logitPrecision = truePos / (truePos + falsePos)
						var recall = truePos/(truePos+falseNeg)

						outputString += "Null deviance: "+nulldev.toFixed(precision) +" on "+totalDF +" degrees of freedom<br>\n"
						outputString += "Residual deviance: "+dev.toFixed(precision) +" on "+withinDF +" degrees of freedom<br>\n"
						outputString += "AIC: "+ (dev + 2*(1+modelN)).toFixed(precision) + "<br>\n"
						outputString += "<br>\n"
						outputString += "<b>Confusion Matrix</b>:<br>\n"
						outputString += "<table class='anova collapse'>\n"
						outputString += "<tr><th></th><th>Predicted 1</th><th>Predicted 0</th><th></tr>\n"
						outputString += "<tr><th>Actual 1</th><td class='blackBorder'>"+truePos+"</td><td class='blackBorder'>"+falseNeg+"</td><td>TPR:"+(recall).toFixed(precision)+"</td></tr>\n"
						outputString += "<tr><th>Actual 0</th><td class='blackBorder'>"+falsePos+"</td><td class='blackBorder'>"+trueNeg+"</td><td>TNR:"+(trueNeg/(trueNeg+falsePos)).toFixed(precision)+"</td></tr>\n"
						outputString += "<tr><th></th><td>Precision: " + (logitPrecision).toFixed(precision)+"</td><td></td><td>Accuracy: " +((truePos + trueNeg)/n).toFixed(precision)+"</td></tr>\n"
						outputString += "</table>\n"
						outputString += "<br>\n"
						outputString += "F Score: "+(2*logitPrecision*recall/(logitPrecision+recall)).toFixed(precision) + "<br>\n"
						outputString += "<strong>Regression Output</strong><br>\n"
						outputString +="<div class='overflowX'>"
						outputString += "<table class='anova'>\n"
						outputString += "<tr><th></th><th>Coefficient</th><th>Std. Error</th><th>z Stat</th><th><i>p</i>-value</th><th>lower "+fixed((1-alpha)*100)+"%</th><th>upper "+fixed((1-alpha)*100)+"%</th></tr>"

						equation+=coeff[modelN].toFixed(precision)

						for(var j=0; j<modelVarNames.length; j++){
							var i=j-1
							if(i==-1) i=modelN;
							if (i<modelN){ 
								equation+=" + "+coeff[i].toFixed(precision) + "<i>"+modelVarNames[j]+"</i>"
							} 						
							var CI = [coeff[i]-jStat.normal.inv(1-alpha/2,0,1)*stdError[i] , coeff[i]+jStat.normal.inv(1-alpha/2,0,1)*stdError[i]]
							outputString += "<tr><td>"+modelVarNames[j]+"</td><td id='b"+i+"'>"+coeff[i].toFixed(precision)+"</td><td>"+stdError[i].toFixed(precision)+"</td><td>"+(coeff[i]/stdError[i]).toFixed(precision)+"</td><td>"+pVals[i].toFixed(precision)+"</td><td>"+ CI[0].toFixed(precision)+"</td><td>"+CI[1].toFixed(precision) +"</td></tr>"
						}
						outputString +="</table>"
						outputString +="</div>"
					}
				
				}
				if(timing) console.log("Linear Regression Performed: "+(new Date().getTime()-startTime))
				document.getElementById("linRegOutput").innerHTML=outputString;
				if(validRegression) document.getElementById("equation").innerHTML=equation
				if(validRegression) buildPrediction(true)

			}

			function buildPrediction(calc=false){
				var startTime = new Date().getTime()
				var logisticReg = (document.getElementById('regressionType').value==2)
				var predictionStringHTML="<strong>Prediction</strong><div class='options'><table class='collapse'>"
				for(var i=1; i<=nCovars+1; i++){
					if(i!=+document.getElementById('ChooseResponse').value){
						if(isFactor[i] || exists("v"+i+"d") && document.getElementById('v'+i+'d').checked==true){
							predictionStringHTML+= "<tr><td>" + document.getElementById('name'+i).value + "</td><td><select id=\"predictX"+i+"\" onChange='calcPrediction();'>"
							for(var k=0; k<levels[i-1].length; k++)
								predictionStringHTML +="<option value=\""+levels[i-1][k]+"\">"+levels[i-1][k]+"</option>"
							predictionStringHTML+="</select></td></tr>"
						} else {
							predictionStringHTML+= "<tr><td>"+ document.getElementById('name'+i).value + "</td><td><input type=\"number\" id=\"predictX"+i+"\" value="+(exists('predictX'+i)?document.getElementById('predictX'+i).value:0)+"  class='mediumNumber' onchange=\"calcPrediction();\" /></td></tr>"
						}
					}
				}
				predictionStringHTML+="</table></div><div class='results'><table class='collapse'>"
				predictionStringHTML+="<tr class='rTop rRow'><td>"
				if(logisticReg){
					predictionStringHTML+="<span class='hat'>log-odds</span>("+document.getElementById('name'+document.getElementById('ChooseResponse').value).value+"=1)=</td><td><span id='predictY'></span></td></tr>"				
					predictionStringHTML+="<tr class='rBot rRow'><td><span class='hat'>prob</span>("+document.getElementById('name'+document.getElementById('ChooseResponse').value).value+"=1)=</td><td><span id='predictProbY'></span>"				
				
				} else {
					predictionStringHTML+="<span class='hat'>"+document.getElementById('name'+document.getElementById('ChooseResponse').value).value+"</span>=</td><td><span id='predictY'></span></td></tr>"
					predictionStringHTML+="<tr class='rRow'><td><span id='predIntLevel'>"+(100*document.getElementById('cLevel').value)+"</span>% Prediction Interval: </td><td>(<span id='PI'></span>)</td></tr>"
					predictionStringHTML+="<tr class='rBot rRow'><td><span id='confIntLevel'>"+(100*document.getElementById('cLevel').value)+"</span>% Confidence Interval: </td><td>(<span id='CI'></span>)</td></tr>"
				}
				predictionStringHTML+="</td></tr></table></div>"
				
				
				document.getElementById('prediction').innerHTML=predictionStringHTML
				if(timing) console.log("Build Prediction: "+(new Date().getTime()-startTime))
				if(calc) calcPrediction()
			}
			
			function calcXh(newX){
				var startTime = new Date().getTime()
				if(debug)console.log("newX = "+newX)
				if(debug)console.log("modelVarNamesVarNum="+modelVarNamesVarNum)
				if(debug)console.log("modelVarNamesFactorValue="+modelVarNamesFactorValue)
				if(debug)console.log("modelVarNamesTransform="+modelVarNamesTransform)
				if(debug)console.log("modelVarIsFactor="+modelVarIsFactor)
				
				var Xh=[]
				if(document.getElementById('regressionType').value==1) Xh.push(1) 
//				console.log(modelVarNamesFactorValue)
				for(var i=1; i<modelVarNames.length; i++){
					if(debug)console.log("var "+i+": "+modelVarNamesVarNum[i])
					var varNums 	= [modelVarNamesVarNum[i]]
//					var varIsFactors=[modelVarIsFactor[i]]
					var varFactorValues=[modelVarNamesFactorValue[i-1]]
					var x=1
					if(typeof(modelVarNamesVarNum[i])=="string"){
						varNums = modelVarNamesVarNum[i].split('.')
//						varIsFactors = modelVarIsFactor[i].split('.')
						console.log(modelVarNamesFactorValue[i-1])
						if(typeof(modelVarNamesFactorValue[i-1])=="string")
						varFactorValues = modelVarNamesFactorValue[i-1].split('.')
					}
					for(var j=0; j<varNums.length; j++){
//						varNums[j] = +varNums[j]
						if(isFactor[+varNums[j]] || exists("v"+varNums[j]+"d") && document.getElementById("v"+varNums[j]+"d").checked){
							x *= (newX[+varNums[j]] == varFactorValues[j] ? 1 : 0)
						}else {
							var t=modelVarNamesTransform[i]
							x *= transform(+newX[+varNums[j]],t)
						}
					}
	//				}
					Xh.push(x)			
				}
				if(document.getElementById('regressionType').value==2) Xh.push(1) 
				if(debug)console.log("Xh="+Xh)
				//if(debug)console.log(numeric.dot(Xh,coeff))
				if(timing) console.log("Xh calculated: "+(new Date().getTime()-startTime))
				return Xh
			}
			
			function calcYFromX(x){
				var Xh = calcXh(x)
				//console.log(Xh)
				return numeric.dot(Xh,coeff)
			}
			
			function calcPrediction(){
				var newX = []
				for(var i=1; i<=nCovars+1; i++){
					newX[i]=(exists('predictX'+i) ? document.getElementById('predictX'+i).value : 0)
				}
				if(debug || debugPred)console.log(newX)
//				var Xh = calcXh(newX)
//				if(debug || debugPred)console.log(coeff)
//				if(debug || debugPred)console.log(Xh)
//				var y=calcYHAT(newX)
//				var y =numeric.dot(Xh,coeff)
								console.log(newX + " -> " + calcYFromX(newX))
				var y = calcYFromX(newX)

				if(document.getElementById('regressionType').value==2) document.getElementById('predictProbY').innerHTML = fixed(Math.exp(y)/(1+Math.exp(y))) 
		/*	
				var y=coeff[0]
				var logisticReg = (document.getElementById('regressionType').value==2)
				if(logisticReg){
					y=coeff[modelN]
					for(var i=1; i<modelVarNames.length; i++){
						if(typeof(modelVarNamesVarNum[i])=="string"){
							console.log("var "+i+" is interaction")
						
						}else if(!modelVarIsFactor[i]){
							var xVal = parseFloat(document.getElementById('predictX'+modelVarNamesVarNum[i]).value)
							if(modelVarNamesTransform[i]==1) xVal = Math.pow(xVal,2)//squared
							if(modelVarNamesTransform[i]==2) xVal = Math.pow(xVal,3)//cubed
							if(modelVarNamesTransform[i]==3) xVal = Math.log(xVal)//ln
							if(modelVarNamesTransform[i]==4) xVal = Math.sqrt(xVal)//sqrt
							y += coeff[i-1]* xVal
						}else{
							var xVal = parseInt(document.getElementById('predictX'+modelVarNamesVarNum[i]).value)
							if(parseInt(modelVarNamesFactorValue[i])==xVal) y+=coeff[i]
						}
					}
					document.getElementById('predictProbY').innerHTML = fixed(Math.exp(y)/(1+Math.exp(y)))
				} else {
					//console.log(modelVarNamesFactorValue)
					for(i=1; i<modelVarNames.length; i++){
						if(typeof(modelVarNamesVarNum[i])=="string"){
							console.log("var "+i+" is interaction: "+modelVarNamesVarNum[i])
							var varNums=modelVarNamesVarNum[i].split('.')

							var quantA=!isFactor[varNums[1]]
							var quantB=!isFactor[varNums[0]]
							if(quantA && quantB){
								y+=coeff[i] * parseFloat(document.getElementById('predictX'+varNums[0]).value) * parseFloat(document.getElementById('predictX'+varNums[1]).value)
							}else{
								var nLevelsA = (quantA?1:levels[varNums[1]-1].length)
								var nLevelsB = (quantB?1:levels[varNums[0]-1].length)
								var varLevels = modelVarNamesFactorValue[i].split(".")
								var xValA=0, xValB =0
								if(quantA){
									xValA=parseFloat(document.getElementById('predictX'+varNums[1]).value)
								} else {
									xValA=(varLevels[1]==document.getElementById('predictX'varNums[1]).value ? 1:0)
								}
								if(quantB){
									xValB=parseFloat(document.getElementById('predictX'+varNums[0]).value)
								} else {
									xValB=(varLevels[0]==document.getElementById('predictX'varNums[0]).value ? 1:0)
								}
								y+=coeff[i]*xValA * xValB
							}
						
						}else if(!modelVarIsFactor[i]){
							var xVal = parseFloat(document.getElementById('predictX'+modelVarNamesVarNum[i]).value)
							if(modelVarNamesTransform[i]==1) xVal = Math.pow(xVal,2)//squared
							if(modelVarNamesTransform[i]==2) xVal = Math.pow(xVal,3)//cubed
							if(modelVarNamesTransform[i]==3) xVal = Math.log(xVal)//ln
							if(modelVarNamesTransform[i]==4) xVal = Math.sqrt(xVal)//sqrt
							y += coeff[i]* xVal
						}else{
							//console.log(modelVarNamesFactorValue[i])
							var xVal = document.getElementById('predictX'+modelVarNamesVarNum[i]).value
					//		console.log(xVal +" =? " + modelVarNamesFactorValue[i-1])
							if(modelVarNamesFactorValue[i-1]==xVal) y+=coeff[i]
						}
					}
				}*/
				document.getElementById('predictY').innerHTML = fixed(y)
				if(document.getElementById('regressionType').value==1){
					if(debug)console.log(XXTinv)
					if(debug)console.log(numeric.dot(Xh, XXTinv))
					var Xh = calcXh(newX)
					var xXXTinvx = numeric.dot(numeric.dot(Xh, XXTinv),Xh)
					if(debug)console.log(xXXTinvx)
					
					var n=getData(0,0).length
					var alpha = 1-parseFloat(document.getElementById("cLevel").value)
					var tstar = jStat.studentt.inv(1-alpha/2,n-modelN-1)
					var cInt = ""
					var pInt = ""
					for(var i=0; i<=1; i++){
						cInt += fixed( y + (i*2-1)*tstar * Math.sqrt(MSE * xXXTinvx)) + (i==0?", ":"")
						pInt += fixed( y + (i*2-1)*tstar * Math.sqrt(MSE * (xXXTinvx+1))) + (i==0?", ":"")
	//					console.log(i+": cint="+cInt)
	//					console.log(i+": pint="+pInt)
					}
				
					document.getElementById('CI').innerHTML=cInt
					document.getElementById('PI').innerHTML=pInt
				}
			}
			
			function calcYHAT(x){
				if(debug)console.log("predict, x="+x)
				var logisticReg = (document.getElementById('regressionType').value==2)
				var YHAT=coeff[(logisticReg?modelN:0)]
				if(debug)console.log("y-hat: "+YHAT)
				for(i=1; i<modelVarNames.length; i++){
					if(typeof(modelVarNamesVarNum[i])=="string"){
						if(debug)console.log("var "+i+" is interaction: "+modelVarNamesVarNum[i])
						var varNums=modelVarNamesVarNum[i].split('.')
						var quantA=!isFactor[varNums[1]]
						var quantB=!isFactor[varNums[0]]
						if(quantA && quantB){
							YHAT+=coeff[i] * parseFloat(x[varNums[0]]) * parseFloat(x[varNums[1]])
						}else{
							var nLevelsA = (quantA?1:levels[varNums[1]-1].length)
							var nLevelsB = (quantB?1:levels[varNums[0]-1].length)
							var varLevels = modelVarNamesFactorValue[i-1].split(".")
							var xValA=0, xValB =0
							if(quantA){
								xValA=parseFloat(x[varNums[1]])
							} else {
								xValA=(varLevels[1]==x[varNums[1]] ? 1:0)
							}
							if(quantB){
								xValB=parseFloat(x[varNums[0]])
							} else {
								xValB=(varLevels[0]==x[varNums[0]] ? 1:0)
							}
							YHAT+=coeff[i]*xValA * xValB
						}
					
					}else if(!modelVarIsFactor[i]){
//						if(modelVarNamesTransform[i]==1) xVal = Math.pow(xVal,2)//squared
//						if(modelVarNamesTransform[i]==2) xVal = Math.pow(xVal,3)//cubed
//						if(modelVarNamesTransform[i]==3) xVal = Math.log(xVal)//ln
//						if(modelVarNamesTransform[i]==4) xVal = Math.sqrt(xVal)//sqrt
						if(debug)console.log(i+": x="+x[modelVarNamesVarNum[i]]+" t="+modelVarNamesTransform[i])
						YHAT += coeff[i]* transform(parseFloat(x[modelVarNamesVarNum[i]]),modelVarNamesTransform[i])
					}else{
						if(debug)console.log(i+": x="+x[modelVarNamesVarNum[i]])
						if(modelVarNamesFactorValue[i-1]==x[modelVarNamesVarNum[i]]) YHAT+=coeff[i]
					}
				if(debug)console.log("y-hat: "+YHAT)
				}
				return YHAT
			}
			
			function prepDataAndCreateScatterplot(){
				var startTime = new Date().getTime()
				var Xfull = numeric.transpose(window.X)
				//alert(document.getElementById("showScatterPlotMatrix").checked)
				if(!document.getElementById("showScatterPlotMatrix").checked){
					var xVals=[]
					var lineYCoords=[]
					var logisticReg = (document.getElementById('regressionType').value==2)
	
					var YVar = parseInt(document.getElementById("ScatterVar1").value)
					var XVar = document.getElementById("ScatterVar2").value
					var catX = XVar.indexOf("c")>-1
					XVar = parseInt(XVar.replace("c",""))
					
					//alert(YVar + " "+XVar + " " +varNames.length)
					if(logisticReg){
						yHat = []
						for(var i=0; i<predictY.length; i++){
							yHat[i]=Math.log(predictY[i]/(1-predictY[i]))
						}
						if(debug)console.log("predict Y" + predictY)
						if(debug)console.log("yHat: "+yHat)
					}
					var Xdata = (XVar==0?window.modelY:(XVar==-1?yHat:Xfull[XVar+(logisticReg?-1:0)]))
					var Ydata = (YVar==0?window.modelY:(YVar==-1?yHat:Xfull[YVar+(logisticReg?-1:0)]))
					
					
					var xLabel = document.getElementById("ScatterVar2").options[document.getElementById("ScatterVar2").selectedIndex].text
					var yLabel = document.getElementById("ScatterVar1").options[document.getElementById("ScatterVar1").selectedIndex].text
					
//					console.log(Xdata)
//					console.log(Ydata)
					//alert(document.getElementById('regressionType').value + " " +logisticReg)
					//if(logisticReg){
					//	Ydata = window.modelY
					//	Xdata = predictY
					//	for(var i=0; i<Xdata.length; i++){
					//		Xdata[i]=Math.log(Xdata[i]/(1-Xdata[i]))
					//	}
					//}	
					//return false;
					
					if(catX){
						xVals=levels[XVar-1]
						Xdata=getColumn(XVar)
						
						for(var i=0; i<Xdata.length; i++){
							for(var k=0; k<xVals.length; k++){
								if(Xdata[i]==xVals[k]) Xdata[i]=k
							}
						}
					
					}else{
						var isInt=true
						var xRange=[Xdata[0],Xdata[0]]
						for(var i=0; i<Xdata.length; i++){
							if(Xdata[i]!=Math.round(Xdata[i],0)) {
								isInt=false
								break;
							}
							xRange[0]=Math.min(xRange[0],Xdata[i])
							xRange[1]=Math.max(xRange[1],Xdata[i])
						}
						if(isInt){
							for(var k=xRange[0]; k<=xRange[1]; k++) xVals.push(k)
						}
					}
					//console.log(Xdata)
	//				console.log(xVals)
					var groupByVarNum = -1
					if(exists('groupColor')) groupByVarNum = +document.getElementById('groupColor').value
					if(debug)console.log(groupByVarNum)
					var group = []
					var legend=[]
					if(groupByVarNum!=-1){
						legend=levels[groupByVarNum-1]
						for(var j=1; j<levels[groupByVarNum-1].length; j++){
							var indicator = getData(groupByVarNum-1, j)
							if(j==1) {
								group=indicator
							} else {
								for(var i=0; i<Xdata.length; i++){
									group[i]+=indicator[i]*j
								}
							}
						}
					}
					if(debug)console.log(group)
					var intercepts=[]
					var slopes=[]
					if(modelN==1){
						intercepts[0]=coeff[0]
						slopes[0]=coeff[1]
					}
					if(XVar==-1){
						intercepts[0]=0	
						slopes[0]=1
					} else {
//						console.log("coeffs:"+coeff)
						if(groupByVarNum!=-1){
							var newX=[]
							for(var j=0; j< levels[groupByVarNum-1].length; j++){
								for(var k=0; k<=1; k++){
									for(var i=0; i<=nCovars+1; i++)newX[i]=k
									newX[groupByVarNum]=levels[groupByVarNum-1][j]
									if(k==0){
										intercepts[j]=calcYHAT(newX)
									}else{
										slopes[j]=calcYHAT(newX)-intercepts[j]
									}
								}
							}
						}
					}
					
					var x=[]
					var y=[]
					if(nQuantPredictors==1 && document.getElementById('ScatterVar1').value==0 && document.getElementById('ScatterVar2').value!=-1 && document.getElementById('showlines').checked && groupByVarNum!=-1){
						console.log("show lines...")
						console.log("groupByVarNum: "+groupByVarNum)
						for(var i=xRange[0]; i<=xRange[1]; i+= (xRange[1]-xRange[0])/40) x.push(i)
						x.push(xRange[1])
						for(var k=0; k<levels[groupByVarNum-1].length; k++){
							y.push([])
							for(var i=0; i<x.length; i++){
								var newX=[]
								for(var j=0; j<=nCovars+1; j++){
									if(j==XVar){
										newX[j+1]=x[i]
									}else if (j==groupByVarNum){
										newX[j]=levels[groupByVarNum-1][k]
									} else {
										newX[j+1]=0
									}
								}
								console.log(newX + " -> " + calcYFromX(newX))
								
								y[k].push(calcYFromX(newX))
							}
						}
						console.log(x)
						console.log(y)
					}
					
					
//					console.log(intercepts + " " + slopes)
					scatterplot(Xdata,Ydata,(XVar==-1), xLabel,yLabel,false,false,false,group,document.getElementById("showlines").checked,x,y,legend,xVals,'scatterplot')		


				} else {
					//prep labels and data
					varLabels=[]
					var scatterData = []
					varLabels[0]=varNames[0]
					for(var i=1; i<=nCovars+1; i++){
						scatterData[i-1]=[]
						varLabels[i-1]=document.getElementById("name"+i).value
						if(isFactor[i]){
							for(var j=0; j<levels[i-1].length; j++){
								var levelData=getData(i-1,j)
								if(j==0){ 
									scatterData[i-1]=levelData
								} else {
									for(var k=0; k<levelData.length; k++){
										scatterData[i-1][k] += levelData[k]*(j+1)
									}
								}
							}
						} else {
							scatterData[i-1]=getData(i-1,0)
						}
					}
					labelScatterPlotMatrix("scatterplot",varLabels);
					for(var i = 0; i<varLabels.length; i++){
						var Xdata = (i==0?window.modelY:Xfull[i+(logisticReg?-1:0)])
						for(var j=i; j<varLabels.length; j++){
							if(i!=j){
								var Ydata = (j==0?window.modelY:Xfull[j+(logisticReg?-1:0)])
//								subScatterPlot(i,j,modelVarNames.length,Xdata,Ydata);
								subScatterPlot(i,j,varLabels.length,scatterData[i],scatterData[j]);
							}else{
//								subHistogram(i,j,modelVarNames.length,Xdata)
								subHistogram(i,j,varLabels.length,scatterData[i],"scatterplot", isFactor[i+1])
							}
						}
					}
				}
			}

			var SPMmargins=[20,10,10,20]

			function labelScatterPlotMatrix(canvasID, names){
				var startTime = new Date().getTime()
				var c=document.getElementById(canvasID)
				var ctx=c.getContext("2d")
				ctx.fillStyle = "white";
				ctx.fillRect(0, 0, c.width, c.height);	
				ctx.fill()
				var scale=c.width/490
				var lMargin=SPMmargins[0]*scale
				var rMargin=SPMmargins[1]*scale
				var tMargin=SPMmargins[2]*scale
				var bMargin=SPMmargins[3]*scale
				var chartWidth = c.width-lMargin-rMargin
				var chartHeight = c.height-tMargin-bMargin		

				ctx.fillStyle="black";
				ctx.font = (12*scale)+"px sans-serif";
				ctx.textAlign = "center";
				ctx.textBaseline = "middle"
				for(var i=0; i<names.length; i++){
					names[i]=names[i].replace("<sub>","(")
					names[i]=names[i].replace("</sub>",")")
					if(debug)console.log(names[i])
					ctx.fillText(names[i], lMargin+(.5+i)*chartWidth/(names.length), c.height-10*scale);
				}
				ctx.save();
				ctx.translate(10*scale, tMargin+chartHeight+bMargin);
				ctx.rotate(-Math.PI/2);
				for(var i=0; i<names.length; i++){
					ctx.fillText(names[names.length-i-1], lMargin+(.5+i)*chartWidth/(names.length), tMargin -10*scale);
				}
				ctx.restore();
			}
			
			function subHistogram(col, row, size, Xdata,canvasID="scatterplot", asBarPlot=false){
				var startTime = new Date().getTime()
				var c=document.getElementById(canvasID)
				var ctx=c.getContext("2d")
				var scale=c.width/490
				var lMargin=SPMmargins[0]*scale
				var rMargin=SPMmargins[1]*scale
				var tMargin=SPMmargins[2]*scale
				var bMargin=SPMmargins[3]*scale
				var chartWidth = c.width-lMargin-rMargin
				var chartHeight = c.height-tMargin-bMargin		
				var n = Xdata.length
				var Xmin = +jStat.min(Xdata)
				var Xmax = +jStat.max(Xdata)
				var Xrng = Xmax-Xmin
				var nBins=8
				if(asBarPlot) nBins=jStat.max(Xdata)
				var freqs=[]
				for(i=0; i<nBins; i++) freqs[i]=0
				var maxFreq=0
				for(var i=0; i<n; i++){
					var j=Math.round((Xdata[i]-Xmin)/Xrng * nBins,0)
					if(asBarPlot)j=Xdata[i]-1
					if(j>=nBins)j=nBins-1
					freqs[j]++
					maxFreq = Math.max(maxFreq, freqs[j]);
					if(debug)console.log( Xdata[i] + "->" + j)
				}
				if(debug)console.log(freqs)
				var x1=lMargin+col*(chartWidth/size)+5 
				var x2=lMargin+(col+1)*(chartWidth/size)-5
				var y1=tMargin+row*(chartHeight/size)+5
				var y2=tMargin+(row+1)*(chartHeight/size)-5

				
				ctx.fillStyle = "rgba("+hexToRgb(colorHex).r +","+hexToRgb(colorHex).g +","+hexToRgb(colorHex).b +",.2)";
				ctx.strokeStyle = "black"
				
				for(var i=0; i<freqs.length; i++){
					ctx.beginPath()
					ctx.fillRect(x1+i*(x2-x1)/nBins+ (asBarPlot?2:0), y2,(x2-x1)/nBins- (asBarPlot?4:0), -freqs[i]/maxFreq * (y2-y1))
					ctx.fill()				
					ctx.rect(x1+i*(x2-x1)/nBins+ (asBarPlot?2:0), y2,(x2-x1)/nBins- (asBarPlot?4:0), -freqs[i]/maxFreq * (y2-y1))
					ctx.stroke()
				}
				ctx.beginPath();
				ctx.rect(lMargin+col*(chartWidth/size),tMargin+row*(chartHeight/size),chartWidth/size,chartHeight/size)
				ctx.stroke();			
			}

			function subScatterPlot(col,row,size,Xdata,Ydata,circleSize=4,canvasID="scatterplot"){
				var startTime = new Date().getTime()
				if(debug)console.log(Xdata)
				if(debug)console.log(Ydata)
			
				circleSize = circleSize /Math.max(size-4,1)
				var c=document.getElementById(canvasID)
				var ctx=c.getContext("2d")
				var scale=c.width/490
				var lMargin=SPMmargins[0]*scale
				var rMargin=SPMmargins[1]*scale
				var tMargin=SPMmargins[2]*scale
				var bMargin=SPMmargins[3]*scale
				var margin = 10*scale
				var chartWidth = c.width-lMargin-rMargin
				var chartHeight = c.height-tMargin-bMargin		
				var n = Xdata.length
				var Xmin = +jStat.min(Xdata)
				var Xmax = +jStat.max(Xdata)
				var Ymin = +jStat.min(Ydata)
				var Ymax = +jStat.max(Ydata)
				for(var i=0; i<n; i++){
					if(Xdata[i]>Xmax) Xmax = Xdata[i];
					if(Xdata[i]<Xmin) Xmin = Xdata[i];
					if(Ydata[i]>Ymax) Ymax = Ydata[i];
					if(Ydata[i]<Ymin) Ymin = Ydata[i];
				}
				var qYrange = Ymax - Ymin
				var qXrange = Xmax - Xmin
				//ctx.beginPath();
				//ctx.rect(lMargin+col*(chartWidth/size),tMargin+row*(chartHeight/size),chartWidth/size,chartHeight/size)
				//ctx.clip();				
				ctx.fillStyle = "rgba("+hexToRgb(colorHex).r +","+hexToRgb(colorHex).g +","+hexToRgb(colorHex).b +",.2)";
				ctx.strokeStyle = "black"
				for(var i=0; i<n; i++){
					var qX = (-Xmin + Xdata[i])/qXrange
					var qY = (-Ymin + Ydata[i])/qYrange
					ctx.beginPath();
					ctx.arc(lMargin+col*(chartWidth/size)+margin+(qX)*(chartWidth/size-margin*2),tMargin+row*(chartHeight/size)+margin+(1-qY)*(chartHeight/size-margin*2), circleSize, 0, 2 * Math.PI);
					ctx.fill();
					ctx.stroke();
				}
				//ctx.restore();	
				ctx.beginPath();
				ctx.rect(lMargin+col*(chartWidth/size),tMargin+row*(chartHeight/size),chartWidth/size,chartHeight/size)
				ctx.stroke();
				
			}

			function refreshQQplot(){
				var qqplotSelect = +document.getElementById('QQselect').value
				if(qqplotSelect==0	){ 
					refreshNormalityPlot(Resid)
				} else {
//					console.log(getData(qqplotSelect-1))
					var qqData = getData(qqplotSelect-1)
					if(qqData) refreshNormalityPlot(qqData.sort(function(a, b){return a-b}))
				}
			}

			function refreshROC(){
				//console.log("Refreshing ROC")
				//console.log(yHat)
				//console.log(Y)
				var Yobs = Y.slice()
				var pY=[]
//				var pOrder=[]
				//console.log(pY)
				for(var i=0; i<yHat.length; i++){
					pY[i]=Math.exp(yHat[i])/(1+Math.exp(yHat[i]))
				}	
				for(var i=1; i<pY.length; i++){
					for(var j=0; j<i; j++){
						if(pY[i] < pY[j]){
							var tempPY=pY[i]
							var tempYOBS = Yobs[i]
							pY[i]=pY[j]
							pY[j]=tempPY
							Yobs[i]=Yobs[j]
							Yobs[j]=tempYOBS
						}
					}
				}
				//console.log(Yobs)
				//console.log(pY)
				
				var FPR=[]
				var TPR=[]
				var P = jStat.sum(Yobs)
				var N = Yobs.length-P
				for(var i=0; i<pY.length; i++){
					var FP=0
					var TP=0
					for(var j=i; j<pY.length; j++){
						if(Yobs[j]==1){
							TP++
						}else{
							FP++
						}
					}
					FPR.push(FP/N)
					TPR.push(TP/P)
				}		
				//console.log(FPR)
				//console.log(TPR)

				for(var i=1; i<FPR.length; i++){
					for(var j=0; j<i; j++){
						if(FPR[i] < FPR[j]){
							var tempFPR=FPR[i]
							var tempTPR=TPR[i]
							FPR[i]=FPR[j]
							FPR[j]=tempFPR
							TPR[i]=TPR[j]
							TPR[j]=tempTPR
						}
					}
				}
				for(var i=1; i<FPR.length; i++){
					for(var j=0; j<i; j++){
						if(TPR[i] < TPR[j]){
							var tempFPR=FPR[i]
							var tempTPR=TPR[i]
							FPR[i]=FPR[j]
							FPR[j]=tempFPR
							TPR[i]=TPR[j]
							TPR[j]=tempTPR
						}
					}
				}
				
				var c=document.getElementById("ROCplot")
				var ctx=c.getContext("2d")
				var scale=c.width/480
				var tMargin=20*scale, bMargin=30*scale, lMargin=50*scale, rMargin=10*scale
				ctx.fillStyle="white"
				ctx.fillRect(0,0,c.width,c.height)
				ctx.fill()
				
				ctx.beginPath()
				ctx.moveTo(c.width-rMargin, tMargin)
				var AOC=0
				for(var i=0; i<FPR.length; i++){
					//hacky correction - I know the curve is flipped, I don't know why
					ctx.lineTo(c.width-rMargin-TPR[i]*(c.width-lMargin-rMargin), tMargin+FPR[i]*(c.height-bMargin-tMargin))
//					ctx.lineTo(lMargin+FPR[i]*(c.width-lMargin-rMargin), c.height-bMargin-TPR[i]*(c.height-bMargin-tMargin))
					if(i==0){
						AOC+=(FPR[i]-0)*(TPR[i]+0)/2
					}else{
						AOC+=(FPR[i]-FPR[i-1])*(TPR[i]+TPR[i-1])/2					
					}
				}
				AOC+=(1-FPR[FPR.length-1])*(1+TPR[FPR.length-1])/2	
				ctx.lineTo(lMargin, c.height-bMargin)
				ctx.stroke()
				ctx.beginPath()
				ctx.setLineDash([5, 3]);
				ctx.moveTo(lMargin, c.height-bMargin)
				ctx.lineTo(c.width-rMargin, tMargin)
				ctx.stroke()

				ctx.beginPath()
				ctx.setLineDash([1, 0]);
				ctx.moveTo(lMargin,tMargin)
				ctx.lineTo(lMargin,c.height-bMargin)
				ctx.lineTo(c.width-rMargin, c.height-bMargin)
				ctx.stroke()
				ctx.textAlign="center"
				ctx.font = "12px  sans-serif";
//				drawXaxis(ctx, lMargin, tMargin, c.height-tMargin-bMargin, c.width-lMargin-rMargin, 10, .1, 0)
				chartAxisX(ctx,c.height-bMargin,lMargin,c.width-rMargin,0,1,5,"False Positive Rate",false,[],fontSizeAxis*scale)
				chartAxisY(ctx,lMargin,c.height-bMargin,tMargin,0,1,5,"True Positive Rate", false,(c.width-lMargin-rMargin),true, fontSizeAxis*scale)
				chartTitle(ctx,"ROC Curve",c.width/2,0, fontSizeTitle*scale)
				document.getElementById('aoc').innerHTML=fixed(AOC)		
			}
			
			function refreshResponseVarLevelOption(){
				var startTime = new Date().getTime()
				if(isFactor[responseVarNum]) document.getElementById('regressionType').value=2
				if(debug)console.log("regression type:"+document.getElementById('regressionType').value)
				var htmlString = ""
				if(document.getElementById('regressionType').value==2){
					htmlString = "<select id='responseVarLevelSelect' onChange='updateResponseVarLevel(); refreshLinRegAndDependencies()'>"
					if (responseVarLevel >=levels[responseVarNum-1].length) responseVarLevel = 0 
					for(var i=0; i<levels[responseVarNum-1].length; i++) 
						htmlString += "<option value="+i+" "+(responseVarLevel==i?' selected':'')+">"+levels[responseVarNum-1][i]+"</option>"
					htmlString +="</select>"
				} 
				document.getElementById('responseVarLevelSpan').innerHTML=htmlString
				document.getElementById('predictYes').style.display=(document.getElementById('regressionType').value==2 ? "inline-block" : "none")
			}
			
			function updateResponseVarLevel(){
				responseVarLevel = +document.getElementById('responseVarLevelSelect').value
				if(debug)console.log("New Response Var Level: "+responseVarLevel)
			}
			
			function enableRegressionType(){
				if(isFactor[responseVarNum]) {
					document.getElementById('regressionType').value=2
					refreshResponseVarLevelOption()
				}
				document.getElementById('regressionType').options[1].disabled = !isLogistic(); 
				document.getElementById('regressionType').options[0].disabled = isFactor[responseVarNum]; 
			}

			function refresh(){
		//	console.log("refresh!")
				if(exists('precision')) setPrecision(document.getElementById('precision').value)
				enableRegressionType()
				cleanData(1)
				refreshCovariates(true,true)
				refreshLinRegAndDependencies()
				sampleStats(nCovars+1)
				refreshQQplot()
			} 
			
			function refreshLinRegAndDependencies(){
				linReg()
				if(debug) console.log("Valid regression: "+validRegression)
				if(validRegression){
					var logisticReg = (document.getElementById('regressionType').value==2)
					rebuildModelVars()
					normality(nCovars+1, true, isFactor, true)		
					prepDataForResidualPlot()
					displayShowLines()
					prepDataAndCreateScatterplot()
					document.getElementById('ROCdiv').style.display=(logisticReg?"block":"none")
					if(!logisticReg){
						getResiduals()
						histogram(residuals,true,"Model Residuals")
					} else {
						refreshROC();
					}
				}
			}

			function updateChooseResponseVar(forceValue=""){
				responseVarNum=+document.getElementById("ChooseResponse").value; 
				document.getElementById('regressionType').options[0].selected = 'selected';
				refreshResponseVarLevelOption();
				rebuildModelCovariatesTable();
				refresh();
			}
		
			function getResiduals(){
				var inputX = new Array()
				
				var outputString = ""
				outputString +=	"<div style='max-height:300px;overflow:auto'>\n"
				outputString += "<table width='100%'>"
				outputString += "<tr><td>Obs.</td>"
				for(i=0; i<nCovars+1; i++){
					outputString +="<td class='unselectable'>"+document.getElementById('name'+(i+1)).value+"</td>"
					inputX.push(getColumn(i+1))
				}
				outputString += "<td class='unselectable'>Predicted</td><td>Residual</td></tr>\n"
				for(var i=0; i<nObs; i++) { 
					outputString += "<tr><td class='unselectable'>"+(i+1)+"</td>"
					for(var j=0; j<nCovars+1; j++){
						outputString += "<td class='unselectable'>"+inputX[j][i] + "</td>"
					}
					outputString += "<td class='unselectable'>"+fixed(yHat[i]) + "</td>"
					outputString += "<td>"+fixed(residuals[i])+"</td></tr>\n"
				}
				outputString += "</table>"
				outputString +=	"</div>\n"
				document.getElementById('allResiduals').innerHTML=outputString
			}
								
			function OnInput() {
				this.style.height = 'auto';
				this.style.height = (this.scrollHeight) + 'px';
			}
			
			function getVarName(varNum){
				return (exists('name'+varNum)?document.getElementById('name'+varNum).value:false)
			}
			
//			This refreshes the select boxes that select
//				1. X variable for residual plot
//				2. Y variable for scatterplot
//					2a. calls rebuildScatterVar2
//				3. Color by: 
			function rebuildModelVars(){
//				var scatterOptions =""
				var colorGrouping="<option value=-1>none</option>"
				for(var i=1; i<=nCovars+1; i++){
					var selected=(document.getElementById('groupColor').value==i)?" selected":""
					if(isFactor[i] /*&& varInModel[i]*/) colorGrouping += "<option value='"+i+"'"+selected+">"+getVarName(i)+"</option>"	
				}
				
				var mod = (document.getElementById("regressionType").value==2 ? "="+levels[responseVarNum-1][responseVarLevel] : "")
				var outputString="<option value='"+0+"' "+(document.getElementById('ScatterVar1').value==0?"selected":"")+">"+varNames[0] +mod+"</option>\n"
				for(i=1; i<=modelN; i++){
					if(!modelVarIsFactor[i]){
						outputString += "<option value='"+i+"' "+(document.getElementById('ScatterVar1').value==i?"selected":"")+">"+modelVarNames[i] +"</option>\n"
					} 
				}
				var catOptions = ""
				for(var i=1; i<=nCovars+1; i++){
					if(isFactor[i] && varInModel[i]) catOptions += "<option value='c"+i+"'>"+getVarName(i)+"</option>"	
				}
				
				var predictedString = "<option value='predicted'>(predicted) "+varNames[0]+"</option>\n"
				document.getElementById("ResidVar").innerHTML=predictedString+"<option value='order'>Observation</option>"+outputString+catOptions;
				document.getElementById("ScatterVar1").innerHTML=outputString + "<option value='-1'>(predicted) "+(document.getElementById('regressionType').value==2?"log-odds ":"")+varNames[0]+"</option>\n";
				document.getElementById('groupColor').innerHTML=colorGrouping
				rebuildScatterVar2();
			}
			
//			Rebuilds the select options for the QQ plot
			function rebuildQQPlotSelect(){
				outputString=""
				for(var i = 0; i<=nCovars+1; i++){
					if(i==0 || !isFactor[i]){
						var selected=""
						if(document.getElementById("QQselect").value==i || i==1 && document.getElementById("QQselect").value>nCovars+1) selected=" selected"
						outputString+="<option value='"+i+"'"+selected+">"+(i==0?"Residuals":document.getElementById("name"+i).value)+"</option>\n"
					}
				}
				document.getElementById("QQselect").innerHTML=outputString
			}

//			This refreshes the select box that selects the scatterplot X variable
			function rebuildScatterVar2(){
			
//			console.log("model var names:"+modelVarNames)
//			console.log("model var names var num:"+modelVarNamesVarNum)
//			console.log("model var is factor:"+modelVarIsFactor)
//			console.log("model var transform:"+modelVarNamesTransform)
				var logisticReg = (document.getElementById('regressionType').value==2)
				var outputString=""
				for(i=0; i<=modelN; i++){
					var vNum = modelVarNamesVarNum[i]
					if(document.getElementById('ScatterVar1').value != i && !modelVarIsFactor[i]){
						outputString += "<option value='"+i+"' "+(document.getElementById('ScatterVar2').value==i?"selected":"")+">"+(i==0?varNames[0]:modelVarNames[i]) +"</option>\n"
					}
				}
				for(var i=1; i<=nCovars+1; i++){
					if(isFactor[i] && varInModel[i]) outputString += "<option value='c"+i+"'"+(document.getElementById('ScatterVar2').value==('c'+i)?" selected":"")+">"+getVarName(i)+"</option>"	
				}
				if(document.getElementById('ScatterVar1').value!='-1')
					outputString +="<option "+(logisticReg?"selected ":"")+"value='-1'>(predicted) "+(document.getElementById('regressionType').value==2?"log-odds ":"")+varNames[0]+"</option>\n"
				document.getElementById("ScatterVar2").innerHTML=outputString;
			}
			
			function changeNCovariates(){
				nCovars = +parseFloat(document.getElementById('nCovars').value)
				nSamples=nCovars+1
				var outputString=""
				for(var i = 1; i<= nCovars+1; i++){
					if(i==1) {var val = "Y" }else{ var val = "X"+(i-1)}
					if(exists("name"+i)) val = document.getElementById("name"+i).value;
					outputString+='<input type="text" id="name'+i+'" value="'+val+'" size="20" maxlength="25" onchange="refreshCovariates(false);" style="position:absolute; left:'+ (48+200*(i-1))+'px; width:201px;"/>'
				}
				document.getElementById('varnames').innerHTML=outputString;			
			}
			
//			This function refreshes the variable name inputs (under Data Input)
//			calls:
//				a. generateSampleStatsTable
//				b. rebuildChooseResponseOptions
//				c. rebuildModelCovariatesTable
//				d. rebuildQQPlotSelect

			function refreshCovariates(regenVarNameInputs=true, calcPrediction=false, forceResponse=""){
				//alert(document.activeElement.tagName)
				//var activeElementID = document.activeElement.id;
				//alert(activeElementID)
				
				nCovars = +parseFloat(document.getElementById('nCovars').value)
				nVars=nCovars+1
				nSamples=nCovars+1
				
//				console.log("refreshing table")
				document.getElementById('wrapper').style.width= (200*nCovars+253)+"px"
				document.getElementById('data1').style.width= (200*nCovars+200)+"px"
				
				if(regenVarNameInputs){
					var outputString=""
					for(var i = 1; i<= nCovars+1; i++){
						if(i==1) {var val = "Y" }else{ var val = "X"+(i-1)}
						if(exists("name"+i)) val = document.getElementById("name"+i).value;
						outputString+='<input type="text" id="name'+i+'" value="'+val+'" size="20" maxlength="25" onchange="refreshCovariates(false);" style="position:absolute; left:'+ (48+200*(i-1))+'px; width:201px;"/>'
					}
					document.getElementById('varnames').innerHTML=outputString;
				}
				varNames=[]
				if(forceResponse!="") responseVarNum= +forceResponse
				for(var i=0; i<nVars; i++) varNames[i]=document.getElementById('name'+(i+1)).value
				generateSampleStatsTable(nCovars+1,true,false,true);
				rebuildChooseResponseOptions()
				rebuildModelCovariatesTable()
				rebuildQQPlotSelect()
				//if(validRegression) refreshQQplot()
				if(validRegression) buildPrediction(calcPrediction)
				//if(exists(activeElementID)) document.getElementById(activeElementID).focus()
			}
						
			function rebuildChooseResponseOptions(){
				outputString=""
				for(var i = 1; i<=nCovars+1; i++){
					var selected=""
					if(responseVarNum==i) selected=" selected"
					if(i==1 && document.getElementById("ChooseResponse").value>nCovars+1) selected=" selected"
					outputString+="<option value='"+i+"'"+selected+">"+document.getElementById("name"+i).value+"</option>\n"
				}
				document.getElementById("ChooseResponse").innerHTML=outputString
			}
			
			function rebuildModelCovariatesTable(){
				outputString=""
				for(var i = 1; i<=nCovars+1; i++){
					if(i != document.getElementById("ChooseResponse").value){
						var data=getColumn(i)
						var n=data.length
						var allInt = true
						var allPos = true
						var someNeg = false
						for(var j=0; j<n; j++){
							if(isFloat(data[j])) allInt = false;
							if (data[j] < 0) {someNeg = true;}
							if (data[j] <= 0) allPos = false;
						}
						outputString+="<tr><td>"+document.getElementById("name"+i).value+"</td>"
						//alert("Var "+i+" is factor?"+isFactor[i])
						for(var k=0; k<5; k++){
							var checked=""
							if(k==0 && !exists("v"+i+"t"+k) && !isFactor[i] ) checked=" checked"
							if (exists("v"+i+"t"+k) && document.getElementById("v"+i+"t"+k).checked==true) checked=" checked"
							outputString += "<td>"
							//var disabled = (isFactor[i]?" disabled":"")
							if(!isFactor[i] && (k<3 || (k==3 && allPos==true) || (k==4 && someNeg==false))) outputString +="<input type='checkbox' id='v"+i+"t"+k+"'"+checked+" onchange='clearDummy("+i+");refreshLinRegAndDependencies();'/>"
							outputString+="</td>"
						}
						
						//Are all checked?
						var checked=""
						if(dataMatrix[0].length==0) checked=""
						if(isFactor[i]) checked=" checked"
						if(exists("v"+i+"d") &&  document.getElementById("v"+i+"d").checked==true){
							checked=" checked"
//							console.log("carvar"+i+" checked!")
						}
						outputString+="<td>"
						if(allInt || isFactor[i]){ 
							outputString+= "<input type='checkbox' id='v"+i+"d'"+checked+" onchange='clearChecks("+i+");rebuildDummyOptions("+i+");refreshLinRegAndDependencies();'/>"
						}
						outputString+="<span id='v"+i+"d0'></span></td>"
						outputString+="</tr>\n"
						if(allInt || isFactor[i]){
							outputString+="<tr id='dummyOptions"+i+"' style='display:none;'><td colspan='6'></td>"
							outputString+="<td id='dummyChoices"+i+"' class='dummyChoices'></td></tr>\n"
						}
					}
				}
				document.getElementById("modelCovariatesTBODY").innerHTML=outputString
				for(var i = 1; i<=nCovars+1; i++){
					if(i != document.getElementById("ChooseResponse").value){
						clearChecks(i)
						var data=getColumn(i)
						var allInt = true
						for(var j=0; j<n; j++){
							if(isFloat(data[j])) allInt = false;
						}
						if(allInt || exists("v"+i+"d") &&  document.getElementById("v"+i+"d").checked==true) rebuildDummyOptions(i)
					}
				}
				rebuildInteractionOptions()
			}
			
			function rebuildInteractionOptions(){
				determineVarsInModel()
				var optionString=""
				var varsFound = 0
				if(debug)console.log("vars in Model: "+varInModel)
				for(var i=1; i<=nCovars+1; i++){
					if(varInModel[i]){
						varsFound++
						if(varsFound>1){
							optionString+="<tr><td>"+getVarName(i)+"</td><td>"
							
							for(var j=1; j<i; j++){
								if(debug)console.log("i="+i+", j="+j)
								if(varInModel[j]){
									var checked=(exists("int_"+i+"."+j) && document.getElementById("int_"+i+"."+j).checked ? ' checked':'')
									optionString +="<input type='checkbox' id='int_"+i+"."+j+"'"+checked+" onClick='refresh();'>"+getVarName(j)+"<br>"
								}
							}
							optionString+="</td></tr>"
						}
					}
				}
				document.getElementById('modelInteractionsTBODY').innerHTML=optionString
			}
			
			function rebuildDummyOptions(varNum){
//				alert("Rebuild dummy "+varNum);
				if(exists("v"+varNum+"d")){
//					console.log("var"+varNum+" checked="+ document.getElementById("v"+varNum+"d").checked)
					var outputString = "";
					if(document.getElementById("v"+varNum+"d").checked==true){
						document.getElementById("dummyOptions"+varNum).style.display="table-row"
						var allDummies=true
						var baselineSelected=false
						for(var k=0; k<levels[varNum-1].length; k++){
							if(exists("v"+varNum+"_"+levels[varNum-1][j])){
								if (!document.getElementById("v"+varNum+"_"+levels[varNum-1][j]).checked){
									allDummies=false;
								} 
								if (document.getElementById("v"+varNum+"_"+k+"_b").checked)
									baselineSelected=true
							}
						}
						//document.getElementById("v"+varNum+"d0").innerHTML="("+document.getElementById("name"+varNum).value+"_"+levels[varNum-1][0]+")"
						for(var j=0; j<levels[varNum-1].length; j++){
							dummyLabel = levels[varNum-1][j]
							var checked = "checked"
							if(exists("v"+varNum+"_"+dummyLabel))
								checked = document.getElementById("v"+varNum+"_"+dummyLabel).checked
							if(allDummies){
								var radioChecked=(baselineLevel[varNum-1]==j ? 'checked':'')
								//if(exists('v'+varNum+'_'+j+'_b')){
								//	radioChecked=(document.getElementById('v'+varNum+'_'+j+'_b').checked?'checked':'')
//									console.log('v'+varNum+'_'+j+'_b is '+radioChecked)
//								} else {
//									console.log('v'+varNum+'_'+j+'_b DNE')
//								}
								if(allDummies && !baselineSelected && j==0) radioChecked="checked"
								outputString+="<input type='radio' id='v"+varNum+"_"+j+"_b' name='baseline"+varNum+"' onclick='baselineLevel["+(varNum-1)+"]="+j+";linReg();' value="+j+(!checked?' disabled':'')+" "+radioChecked+">"
							}
							var checkVis = (levels[varNum-1].length>=3 ? "inline":"none") 
							outputString+="<span id='v"+varNum+"_"+j+"_lbl'><input type='checkbox' id='v"+varNum+"_"+dummyLabel+"'"+checked+" onchange='disableRadio("+varNum+","+j+");linReg();' style='display:"+checkVis+"'/>"
							outputString += ""+/*document.getElementById("name"+varNum).value+"<sub>"+*/dummyLabel /*+ "</sub>*/+"</span><br>\n"
						}
						
						
						document.getElementById('dummyChoices'+varNum).innerHTML = outputString
		//				alert(outputString)
						
					} else {
						document.getElementById('dummyChoices'+varNum).innerHTML = outputString
						document.getElementById("dummyOptions"+varNum).style.display="none"
					}
				}
			}
			
			function disableRadio(varNum,j){
				var noDummies=true
				var allDummies=true
				for(var k=0; k<levels[varNum-1].length; k++){
					if(exists("v"+varNum+"_"+levels[varNum-1][k])){
						if (!document.getElementById("v"+varNum+"_"+levels[varNum-1][k]).checked){
							document.getElementById("v"+varNum+"_"+k+"_lbl").className="baseline"
							allDummies=false;
							document.getElementById("v"+varNum+"_"+k+"_b").checked=true
							baselineLevel[varNum-1]=k
						}else {
							document.getElementById("v"+varNum+"_"+k+"_lbl").className=""
							noDummies= false;
						}
					}else {
						noDummies = false
					}
				}
			
				
				for(var i=0; i<levels[varNum-1].length; i++){
					document.getElementById("v"+varNum+"_"+i+"_b").disabled=!allDummies
					document.getElementById("v"+varNum+"_"+i+"_b").style.display= (allDummies?"":"none")
				}
				//document.getElementById("v"+varNum+"_"+0+"_b").checked=true
				if(noDummies){ 
					document.getElementById("v"+varNum+"d").checked=false
					document.getElementById("dummyOptions"+varNum).style.display="none"
				}
			}
			
			function clearChecks(varNum){
				if(exists("v"+varNum+"d") && document.getElementById("v"+varNum+"d").checked==true){
					for(var k=0; k<5; k++){
						if(exists("v"+varNum+"t"+k)) document.getElementById("v"+varNum+"t"+k).checked=false
					}
				}
				//rebuildInteractionOptions()
			}
			
			function clearDummy(varNum){
				if(exists("v"+varNum+"d")){
					document.getElementById("v"+varNum+"d").checked=false
					document.getElementById("dummyOptions"+varNum).style.display="none"
				}
//				rebuildInteractionOptions()
			}
			
			function initialOptions(){
//				console.log("initial options!")
				for(var i = 1; i<=nCovars+1; i++){
					if(i != document.getElementById("ChooseResponse").value){
						if(!isFactor[i]) {
							document.getElementById("v"+i+"t0").checked=true
						} else {
							document.getElementById("v"+i+"d").checked=true
						}
					}
				}
			}
			
			function share(){
				makeURL(nCovars+1,false)
			}

			function buildDataTableFromURL(){
				for(var i=1; i<=51; i++){
					if(getQueryVariable("name"+i)!=false){
						nSamples = i;
						nCovars=i-1;
					}
				}
				document.getElementById('nCovars').value=nCovars;
				if(getQueryVariable("response")!=false){
					responseVarNum = getQueryVariable("response")
				}
				changeNCovariates()
				parseDataFromURL(nCovars+1)
				cleanData(1)
				refreshCovariates();
				//cleanData(1)
			}
			
			function handleTab(){
				if(event.keyCode===9){var v=this.value,s=this.selectionStart,e=this.selectionEnd;this.value=v.substring(0, s)+'\t'+v.substring(e);this.selectionStart=this.selectionEnd=s+1;return false;}
			}
			
			function startup(){
				TLN.append_line_numbers('data1');
				enableTab('data1');
				buildDataTableFromURL();
				updateChooseResponseVar();
//				cleanData(1);
				generateSampleStatsTable(nCovars+1,true);
				rebuildModelCovariatesTable();
				initialOptions();
				loadPrecision();
				loadColorChoice();
				linkMenu();
				setColors();
			}
			
			function displayShowLines(){
//				console.log("n quant predictors = "+nQuantPredictors)
				if(document.getElementById("ScatterVar2").value==-1 || nQuantPredictors==1 || nCovars==1){
					document.getElementById("showLinesSpan").style.display="inline"
					document.getElementById("showlines").checked=true			
				} else {
					document.getElementById("showlines").checked=false			
					document.getElementById("showLinesSpan").style.display="none"				
				}
			}
			
			
			function refreshData(){
				//create the data matrix
				cleanData(1)
				refresh()
			}
						
			function toggleHideInteractions(){
				document.getElementById('modelInteractions').classList.toggle('hideRows')
			}
		</script>
		<style>
		.hideRows tbody{
			display:none;
		}
		
		.invisCheck{
			/*display:None;*/
		}
		.invisCheck:checked + .strikeThroughLabel{
			text-decoration: none;
		}
		.invisCheck + .strikeThroughLabel{
			text-decoration: line-through;
		}
		radio[disabled] {color:#EEE;}
		
		:checked + span {font-style: italic; color: #999;}
		.baseline { font-style: italic; color: #999;}
		
		.dummyChoices{border: 1px solid gray; background-color:#F5F5F5;}
		
		.blackBorder{border: 1px solid black;}
		
		.collapse{border-collapse: collapse;}
		
		.interactionTable {border:solid black 1px;}
		.interactionTable tr{border-bottom: solid #DDD 1px;}
		.interactionTable th{padding-right: 4px;}
		.interactionTable td{vertical-align:top; padding-right: 4px;}
		
		#dataMatrix{overflow-x: auto;}
		#corMatrix{overflow-x: auto;}
		
		.rTop td, .rRow td, .rBot td{
			background-color:#FFC;
			margin:.1em;
			border-radius:.2em;
			padding: .2em;
		}
		tr.rTop td{border-top:black solid .01em;}
		tr.rBot td{border-bottom:black solid .01em;}
		tr.rRow td:first-child{border-left:black solid .01em;}
		tr.rRow td:last-child{border-right:black solid .01em;}

		</style>
	</head>
	
	<body onload="startup();">
		<div id="container">
			<div id="title" onClick="setColors()">StatPowers</div>
			<div id="menu"></div>
			<form name="form1">
				<div class="container" >
					<input type="checkbox" checked name="headerDataEntry" id="headerDataEntry" class="css-checkbox">
					<label for="headerDataEntry" class="css-label">Data Entry</label>
					<div class="content css-content">
						Enter data separated by 
						<input class="invisCheck" type="checkbox" checked id="delimComma"><label for="delimComma" class="strikeThroughLabel">comma</label>, 
						<input class="invisCheck" type="checkbox" checked id="delimSemicolon"><label for="delimSemicolon" class="strikeThroughLabel">semicolon</label>, 
						<input class="invisCheck" type="checkbox" checked id="delimSpace"><label for="delimSpace" class="strikeThroughLabel">space</label> or 
						<input class="invisCheck" type="checkbox" checked id="delimTab"><label for="delimTab" class="strikeThroughLabel">tab</label>.<br>
						Each observation should be placed on a new line.<br>
						Independent Variables: <input id="nCovars" type="number" min="1" max="50" step="1" value="2" required="true" onChange="refreshCovariates()" /><br>
						<div style="width:100%; box-sizing:border-box;">
						<div style="max-height:500px; width:100%; overflow:auto;">
							<span style="color:red">Variables:</span> 
							<div id="varnames" style="position:relative;height:10px;">
								<input type="text" id="name1" value="Y" size="20" maxlength="25" onchange='refreshCovariates(false);' style="position:absolute; left:49px; width:200px;"/>
								<input type="text" id="name2" value="X1" size="20" maxlength="25" onchange='refreshCovariates(false);' style="position:absolute; left:249px; width:200px;" />
								<input type="text" id="name3" value="X2" size="20" maxlength="25" onchange='refreshCovariates(false);' style="position:absolute; left:449px; width:200px;" />
							</div>
							<div id="wrapper">
								<textarea name="data1" id="data1" class="fauxTable niceCols grid multicol" rows=6 cols=60 onkeydown="handleTab()" onchange="refreshData()"></textarea>
								
							</div>
						</div>
						</div>
						<button TYPE=button VALUE="Calculate Now" onClick="refresh()">Calculate Now</button>
						&nbsp;&nbsp;&nbsp;
						<button TYPE=reset VALUE="Clear All" onClick="document.getElementById('data1').innerHTML='';document.getElementById('dataLink').innerHTML='';">Clear All</button>
						&nbsp;&nbsp;&nbsp;
						<button TYPE=button VALUE="Share Data" onClick="share()">Share Data</button> 
					<div id="dataLink" ></div><iframe id="frmFile" style="display: none;"></iframe>
					</div>
				</div>
				<div class="container">
					<input type="checkbox" id="headerSummaryStats" class="css-checkbox">
					<label for="headerSummaryStats" class="css-label">Summary Statistics</label>
					<div class="content css-content">
						<div class="results">
						<div id="output">
						</div>
						<div id="corMatrix">
						</div>
						</div>
					</div>
				</div>
				<div class="container">
					<h3>Charts</h3>
					<div>
						<input type="checkbox" id="headerScatter" class="css-checkbox">
						<label for="headerScatter" class="css-label sub">Scatter Plot</label>
						<div class="content css-content">
							<div  class='options'>
							<input type="checkbox" id="showScatterPlotMatrix" onChange = "prepDataAndCreateScatterplot(); document.getElementById('scplotVars').style.display=(this.checked?'none':'block');">
							<label for="showScatterPlotMatrix">Scatter Plot Matrix</label><br>
							<div id='scplotVars'>
								Vertical-Variable: 
								<select id="ScatterVar1" onchange="rebuildScatterVar2();prepDataAndCreateScatterplot();">
								</select><br>
								Horizontal-Variable: 
								<select id="ScatterVar2" onchange="displayShowLines();prepDataAndCreateScatterplot();">
								</select><br>

								<span id="showLinesSpan" style="display:none;"><input type="checkbox" id="showlines" onClick="prepDataAndCreateScatterplot();">
								<label for="showlines">Line(s)</label></span>
								<span id="colorBySpan">
								Color by:<select id="groupColor" onChange="prepDataAndCreateScatterplot()">
									<option>none</option>
								</select>
								</span>
							</div>
							</div>
							<div class="canvasdiv">
							<canvas id="scatterplot" width="490" height="500" class='zoomable'>
								<p>Your browser doesn't support canvas. Please update your browser.</p>
							</canvas>
							<a class="downloadButton bottomleft"  href="" onClick="downloadCanvas(this,'scatterplot','scatterplot.png');"></a>
							</div>
						</div>
					</div>
					<div>
						<input type="checkbox" id="headerResid" class="css-checkbox">
						<label for="headerResid" class="css-label sub">Residual Plot</label>
						
						<div class="content css-content">
						<div  class='options'>
							Horizontal-Variable: 
							<select id="ResidVar" onchange="prepDataForResidualPlot();">
							</select> 
							<input type='checkbox' id='absResid' onClick="prepDataForResidualPlot();">
							<label for='absResid'>Absolute Values</label>
						</div>
						<div class="canvasdiv">
							<canvas id="residualplot" width="490" height="490" class='zoomable'>
								<p>Your browser doesn't support canvas. Please update your browser.</p>
							</canvas>
							<a class="downloadButton bottomleft"  href="" onClick="downloadCanvas(this,'residualplot','residualplot.png');"></a>
							</div>
						</div>
					</div>
					<div id="ROCdiv">
						<input type="checkbox" id="headerROC" class="css-checkbox">
						<label for="headerROC" class="css-label sub">ROC</label>
						<div class="content css-content">
							<div class="canvasdiv">
							<canvas id="ROCplot" width="490" height="500" class='zoomable'>
								<p>Your browser doesn't support canvas. Please update your browser.</p>
							</canvas>
							<a class="downloadButton bottomright"  href="" onClick="downloadCanvas(this,'ROCplot','ROCplot.png');"></a>
							</div>
							<div class='results'>
							Area Under the Curve (AOC): <span id='aoc'></span>
							</div>
						</div>
					</div>
				</div>
				<div class="container">
					<input type="checkbox" id="headerNormality" class="css-checkbox" onClick="refreshQQplot()">
					<label for="headerNormality" class="css-label">Normality</label>
					<div class="content css-content">
						
						<div class='options'>
						QQ Plot: <select id='QQselect' onChange='refreshQQplot()'></select> <a name='refreshQQ' onClick='refreshQQplot()' class='fauxButton'>&#8635;</a>
								<input type="checkbox" id="qqbands" onClick="refreshQQplot();"> 95% Bands
								<input type="checkbox" id="wormPlot" onClick="refreshQQplot();"> Worm Plot
						</div>

						
						<div class="canvasdiv">
							<canvas id="qqPlot" width="490" height="400" class='zoomable'>
								<p>Your browser doesn't support canvas. Please update your browser.</p>
							</canvas>
						<a class="downloadButton bottomleft"  href="" onClick="downloadCanvas(this,'qqPlot','qqPlot.png');"></a> </div>
						<div id="normality" class='results'></div>
					</div>
				</div>
				<div class="container">
					<input type="checkbox" id="headerLinRegOptions" class="css-checkbox">
					<label for="headerLinRegOptions" class="css-label">Regression Options</label>
					<div class="content css-content">
						<div class='options'>
						Confidence Level
						<input type="number" id="cLevel" value="0.95" class="smallNumber" min="0" max="1" step=".01"  onchange="refreshLinRegAndDependencies();" /><br>
						Response Variable: 
						<select id="ChooseResponse" onchange="updateChooseResponseVar();">
							<option value="1" selected>Y</option>
							<option value="2">X1</option>
							<option value="3">X2</option>
						</select> 
						Transformation: 
						<select id="responseTransform" onchange="refresh();">
							<option value="1" selected>none</option>
							<option value="2">Log</option>
						</select><br>
						Regression Type:
						<select id="regressionType" onClick = "document.getElementById('regressionType').options[1].disabled = !isLogistic();" onchange="refreshResponseVarLevelOption();refresh();">
							<option value="1" selected>Linear</option>
							<option value="2">Logistic</option>
						</select> <span id="responseVarLevelSpan"></span><span id='predictYes'> | Threshhold:<input type='number' id='predictYesLevel' class="tinyNumber" min=0 max=1 step=.01 value=.5 onChange=refresh();></span><br>
						
						
						Model Covariates:
						<table class="anova" id="modelCovariates">
							<thead>
								<tr><td rowspan=2>Variable</td><td colspan=5 style="text-align:center">Transformation</td></tr>
								<tr><td>x</td><td>x<sup>2</sup></td><td>x<sup>3</sup></td><td>ln(x)</td><td>&radic;<span style="text-decoration:overline">x</span></td><td>Categorical</td></tr>
							</thead>
							<tbody id="modelCovariatesTBODY">
							</tbody>
						</table>
						
						<table class='interactionTable collapse hideRows' id="modelInteractions">
							<thead>
								<tr class='perm'><th><input type=checkbox onchange="toggleHideInteractions()">Variable</th><th>Interactions</th></tr>
							</thead>
							<tbody id="modelInteractionsTBODY">
							</tbody>
						</table>
						</div>
						<!--a name='refreshLinReg' onClick='refreshLinRegAndDependencies()' class='fauxButton'>&#8635;</a-->
						<!--pre id="Xdata"></pre-->
					</div>
				</div>
				<div class="container">
					<input type="checkbox" id="headerLinRegOutput" class="css-checkbox">
					<label for="headerLinRegOutput" class="css-label">Regression Output</label>
					<div class="content css-content">
						<div id="linRegOutput" class='results'>
						</div>
						<div id='prediction'></div>
					</div>
				</div>
				<div class="container" id="residContainer">
					<input type="checkbox" id="headerHistogram" class="css-checkbox" onClick="histogram(residuals.slice(),true,'Model Residuals')">
					<label for="headerHistogram" class="css-label">Residuals</label>
					<div class="content css-content">
						<input id='nBinsOverride' value='fd' hidden style="display:none;">
						<input type=checkbox id='discrete' hidden style="display:none;">
						<input id='varName1' value='residual' hidden style="display:none;">
						<input id='varUnits1' value ='' hidden style="display:none;">
						<div class="canvasdiv">
							<canvas id="histogram" width="490" height="350" class='zoomable'>
								<p>Your browser doesn't support canvas. Please update your browser.</p>
							</canvas>
							<a class="downloadButton topright"  href="" onClick="downloadCanvas(this,'histogram','residualHistogram.png');"></a>
							</div>
						<div id='allResiduals' class='results'></div>
					</div>
				</div>	
				<div id='dataMatrix' class='results'>
				</div>
			</form>
		</div>
	</body>
</html>

<script>
if(!debug) document.getElementById('dataMatrix').style.display="none"
/*	var tx = document.getElementsByTagName('textarea');

	for (var i = 0; i < tx.length; i++) {
		tx[i].setAttribute('style', 'height:' + (tx[i].scrollHeight) + 'px;overflow-y:hidden;');
		tx[i].addEventListener("input", OnInput, false);
	}*/
</script>